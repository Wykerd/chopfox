/**
 *  This file is part of Chopfox.
 *
 *  Chopfox is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chopfox is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with Chopfox.  If not, see <https://www.gnu.org/licenses/>.
 */
import { crop_frames, get_panels_rgb, free_mat_vector } from './extract'

export function SimpleComicData () {}
SimpleComicData.prototype.panels = [];
SimpleComicData.prototype.frames = [];

export function SimpleProcessor () {}
SimpleProcessor.prototype.log_level = 0;
SimpleProcessor.prototype.panel_precision = 0.001;
SimpleProcessor.prototype.panel_min_area_divider = 15.0;

/**
 * Create a new SimpleProcessor object.
 * @param {number} log_level Value between 0-3 for logging to stdout
 * @param {number} panel_precision Used in contour appoximation
 * @param {number} panel_min_area_divider Min area of panel calculates as min_area = (strip.width / panel_min_area_divider) * (strip.height / panel_min_area_divider) 
 * @returns {SimpleProcessor} The SimpleProcessor
 */
export function simple_processor_init_notext (
    log_level = 0, 
    panel_precision = 0.001,
    panel_min_area_divider = 15.0
) {
    const ret = new SimpleProcessor();

    ret.log_level = log_level;
    ret.panel_precision = panel_precision;
    ret.panel_min_area_divider = panel_min_area_divider;

    return ret;
}

/**
 * Get the panel regions from imput image
 * @param {SimpleProcessor} proc The processor struct to use containing the options
 * @param {cv.Mat} img The input image
 * @param {SimpleComicData} out The resulting data
 */
export function simple_process_panels (
    proc,
    img,
    out
) {
    out.panels = get_panels_rgb(img, proc.panel_precision, proc.panel_min_area_divider);

    if (proc.log_level >= 1) console.log(`[Chopfox] Found ${out.panels.length} panels\n`);
}

/**
 * Chop up the images after getting the panels with simple_process_panels
 * @param {SimpleProcessor} proc The processor struct to use containing the options
 * @param {cv.Mat} img The input image
 * @param {SimpleComicData} out The resulting data
 */
export function simple_process_chop (
    proc,
    img,
    out
) {
    out.frames = crop_frames(img, out.panels);

    if (proc.log_level >= 1) console.log("[Chopfox] Chopped up panels...\n");
}

/**
 * Draw the bounding boxes generated by simple_process_chop & simple_process_text
 * @param {SimpleComicData} data The data containing the bounding boxes & contours
 * @param {cv.Mat} dst The destination image to draw to
 * @param {cv.Scalar} panel_color Color of the panel contours
 * @param {number} panel_thickness Thickness of the panel contours
 */
export function simple_draw_bounding_boxes (
    data,
    dst,
    panel_color,
    panel_thickness
) {
    for (let i = 0; i < data.panels.length; i++) {
        const cnt = new cv.MatVector();
        cnt.push_back(data.panels[i].contour);
        cv.drawContours(dst, cnt, -1, panel_color, panel_thickness);
    }
}

/**
 * Free the data
 * @param {SimpleComicData} data 
 */
export function  simple_data_free (data) {
    free_mat_vector(data.frames);
}

/**
 * Generate XML representation of the data
 * @param {SimpleComicData} data 
 * @param {boolean} include_contour Include the contour points of the panels in the XML output
 * @returns The resulting XML DOM
 */
export function simple_xml_info (
    data,
    include_contour
) {
    const doc = document.implementation.createDocument("", "", null);
    const gen = doc.createComment("Generated by Chopfox web version");
    doc.appendChild(gen);
    const root = doc.createElement('comic-strip');
    for (let i = 0; i < data.panels.length; i++) {
        const panel = doc.createElement('panel');
        panel.setAttribute('top', data.panels[i].bounding_box.x);
        panel.setAttribute('left', data.panels[i].bounding_box.y);
        panel.setAttribute('width', data.panels[i].bounding_box.width);
        panel.setAttribute('height', data.panels[i].bounding_box.height);
        if (include_contour) {
            panel.setAttribute('coutour_data', data.panels[i].contour.data32S.join(' '))
        }
        root.appendChild(panel);
    }
    doc.appendChild(root);
    return doc;
}

/**
 * Load image from URL
 * @param {string} src Image source URL
 */
export function simple_load_image (
    src
) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0 );
            const img_data = context.getImageData(0, 0, img.width, img.height);
            resolve(cv.matFromImageData(img_data));
        }
        img.onerror = reject;
    });
}